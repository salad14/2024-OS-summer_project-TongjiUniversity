Q1:Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

answer:在 RISC-V 架构中，函数调用的前8个参数是通过寄存器传递的，分别是 a0 到 a7。具体来说：
a0：第1个参数 a1：第2个参数 依此类推 查看call.asm文件中的main函数可知，在 main 调用 printf 时，由寄存器 a2 保存 13。

Q2:Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

answer:查看call.asm文件中的f和g函数可知，函数 f 调用函数 g ；函数 g 使传入的参数加 3 后返回。编译器会进行内联优化，即一些编译时可以计算的数据会在编译时得出结果，而不是进行函数调用。查看 main 函数可以发现，printf 中包含了一个对 f 的调用。但是对应的会汇编代码却是直接将 f(8)+1 替换为 12 。这就说明编译器对这个函数调用进行了优化，所以对于 main 函数的汇编代码来说，其并没有调用函数 f 和 g ，而是在运行之前由编译器对其进行了计算。

Q3:At what address is the function printf located?

answer:查阅得到其地址在 0x628。

Q4:What value is in the register ra just after the jalr to printf in main? 0：使用 auipc ra,0x0 将当前程序计数器 pc 的值存入 ra 中。

answer:34：jalr 1536(ra) 跳转到偏移地址 printf 处，也就是 0x630 的位置。
根据 reference1 中的信息，在执行完这句命令之后， 寄存器 ra 的值设置为 pc + 4 ，也就是 return address 返回地址 0x38。即jalr 指令执行完毕之后，ra 的值为 0x38.

Q5:Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
What is the output? [Here's an ASCII table](ASCII Table - ASCII Character Codes, HTML, Octal, Hex, Decimal) that maps bytes to characters.

The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.

answer:
运行结果：打印出了 He110 World。

i 的值是 0x00646c72，它表示的字符串是 rl，因为 RISC-V 是小端序，所以字节顺序是反的。

57616 在十六进制中是 e110。

故输出 He110 World

Q6:In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);

answer:
printf 函数期望有两个参数：x 和 y。 由于代码中只传递了一个参数 3，所以 y 部分的输出将是未定义的行为，可能会打印一些垃圾值，因为第二个参数 y 没有提供。 可能导致 y 打印出一个随机的值或导致程序崩溃。