Q1：为什么 thread_switch 只需要保存/恢复被叫方保存寄存器？

answer：在调用 thread_switch 函数时，我们只需要保存被叫方保存的寄存器（即 callee-saved registers），因为这些寄存器在上下文切换后仍需保持其原有值。被叫方保存的寄存器通常包括 s0-s11 等。被叫方寄存器在子程序调用后返回时不会被调用者修改，这意味着它们需要在切换到其他线程时保留原始的上下文信息。调用者保存的寄存器（caller-saved registers）在函数调用之间可能会被调用者覆盖，因此不需要在 thread_switch 中专门保存。

Q2：在多线程环境中，为什么缺少密钥会发生在有两个线程的情况下，而不是在单线程情况下？

answer:在有两个线程的情况下，缺少密钥的问题通常是由于竞争条件（race condition）导致的。当多个线程同时尝试向哈希表中插入或获取相同的键时，如果没有适当的同步机制（如锁），这些线程可能会互相覆盖对方的操作，导致部分键未能正确插入或读取。在单线程情况下，不会发生这样的竞争，因此不会出现密钥缺失的问题。